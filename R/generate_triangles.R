#' Generate retrospective reporting triangles
#'
#' This function ingests a list of truncated reporting triangles and iteratively
#'   generates the reporting triangle that would have been available as of the
#'   maximum reference time. It operates on each element in the list in order
#'   (from most recent retrospective nowcast time to oldest retrospective
#'   nowcast time).
#'
#' @param trunc_rep_tri_list List of `n` truncated reporting triangle
#'   matrices with as many rows as available given the truncation.
#' @inheritParams generate_triangle
#' @returns `reporting_triangle_list` List of retrospective reporting triangles,
#'   generated by removing the bottom right observations from the truncated
#'   reporting triangle matrices.
#' @importFrom cli cli_abort
#' @export
#' @examples
#' triangle <- matrix(
#'   c(
#'     65, 46, 21, 7,
#'     70, 40, 20, 5,
#'     80, 50, 10, 10,
#'     100, 40, 31, 20,
#'     95, 45, 21, NA,
#'     82, 42, NA, NA,
#'     70, NA, NA, NA
#'   ),
#'   nrow = 7,
#'   byrow = TRUE
#' )
#'
#' trunc_rts <- truncate_triangles(triangle, n = 2)
#' retro_rts <- generate_triangles(trunc_rts)
#'
#' # With custom structure
#' retro_rts_custom <- generate_triangles(
#'   retro_rts,
#'   structure = 2
#' )
#' retro_rts_custom
generate_triangles <- function(trunc_rep_tri_list, structure = 1) {
  # Check that input is a list of matrices
  if (!is.matrix(trunc_rep_tri_list[[1]])) {
    cli_abort(
      message = "The elements of `reporting_triangle_list` must be matrices"
    )
  }

  reporting_triangle_list <- lapply(
    trunc_rep_tri_list,
    generate_triangle,
    structure = structure
  )

  return(reporting_triangle_list)
}

#' Generate a single retrospective reporting triangle
#'
#' This function generates a single reporting triangle by removing the bottom
#'   right observations from a truncated reporting triangle matrix. It is the
#'   singular version of `generate_triangles()`.
#'
#' @param trunc_rep_tri A single truncated reporting triangle. May or may
#'    not contain NAs.
#' @param structure Integer or vector specifying the reporting structure.
#'   If integer, divides columns evenly by that integer (with last possibly
#'   truncated).  If vector, be less than one less than the number of columns.
#'   Default is 1 (standard triangular structure).
#' @returns A single retrospective reporting triangle matrix with NAs in the
#'   appropriate positions.
#' @export
#' @examples
#' triangle <- matrix(
#'   c(
#'     65, 46, 21, 7,
#'     70, 40, 20, 5,
#'     80, 50, 10, 10,
#'     100, 40, 31, 20,
#'     95, 45, 21, 10,
#'     82, 42, 6, NA,
#'     70, 90, NA, NA
#'   ),
#'   nrow = 7,
#'   byrow = TRUE
#' )
#'
#' # Standard triangular structure (default)
#' rep_tri <- generate_triangle(triangle)
#' rep_tri
#'
#' # Ragged structure with 2 columns per delay period
#' rep_ragged <- generate_triangle(triangle, 2)
#' rep_ragged
#'
#' # Custom structure with explicit column counts
#' rep_custom <- generate_triangle(triangle, c(1, 2))
#' rep_custom
generate_triangle <- function(trunc_rep_tri, structure = 1) {
  # Get matrix dimensions
  rows <- nrow(trunc_rep_tri)
  cols <- ncol(trunc_rep_tri)

  # Create a copy of the input matrix
  result <- trunc_rep_tri

  # Process structure parameter
  if (length(structure) == 1) {
    structure_vec <- .expand_structure_vec(structure, cols)
  } else {
    # Vector case
    structure_vec <- structure

    if (sum(structure_vec) > (cols - 1)) {
      cli_abort(
        message = "Sum of structure vector must less than or equal to one less than the number of columns in matrix", # nolint
      )
    }
  }

  # For each row, determine which columns should be NA
  cutoff_cols <- cumsum(structure_vec) + 1

  for (i in seq_along(structure_vec)) {
    index_row <- rows - i + 1
    start_col <- cutoff_cols[i]
    result[index_row, start_col:cols] <- NA_real_
  }

  return(result)
}

.expand_structure_vec <- function(structure, cols) {
  if (structure <= 0) {
    cli_abort("Structure must be positive")
  }

  if (structure > cols) {
    cli_abort("Structure cannot be larger than number of columns")
  }
  adjusted_cols <- cols - 1

  n_complete_groups <- floor(adjusted_cols / structure)

  structure_vec <- rep(structure, n_complete_groups)

  remainder <- adjusted_cols %% structure

  if (remainder > 0) {
    structure_vec <- c(structure_vec, remainder)
  }

  return(structure_vec)
}
